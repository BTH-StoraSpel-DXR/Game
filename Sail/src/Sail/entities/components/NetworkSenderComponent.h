#pragma once
#include "Component.h"
#include "Sail/netcode/NetworkedStructs.h"
#include <vector>

#define SHIFT_AMOUNT 18

class NetworkSenderComponent : public Component<NetworkSenderComponent> {
public:
	/*
	  type will decide which components are modified for the entity this component belongs to
	  The ownerID is the ID of the player and is used to create a unique ID for the network component
	
	  The first byte of the object ID is set to the ownerID and the rest to the unique ID generated by the player
	*/
	NetworkSenderComponent(Netcode::MessageType dataType, Netcode::EntityType entityType, unsigned char ownerID) :
		m_id(Netcode::createNetworkID() | (static_cast<Netcode::NetworkComponentID>(ownerID) << SHIFT_AMOUNT)),
		m_entityType(entityType) {
		
		addDataType(dataType);
	}

	/*
	  This function should only be used by the host to create pass-through sender components.
	*/
	NetworkSenderComponent(Netcode::MessageType dataType, Netcode::EntityType entityType, Netcode::NetworkComponentID objectID) :
		m_id(objectID), m_dataType(dataType), m_entityType(entityType) {
		m_dataTypes.push_back(dataType);
	}

	~NetworkSenderComponent() {}

	void addDataType(Netcode::MessageType type) { m_dataTypes.push_back(type); }
	void removeDataType(Netcode::MessageType type) {
		// Search through dataType vector
		for (int i = 0; i < m_dataTypes.size(); i++) {
			// If found...
			if (m_dataTypes.at(i) == type) {
				// ... Then delete
				m_dataTypes.erase(m_dataTypes.begin() + i);
			}
		}

		// Then, if size is 0, queue a deletion of this component.
		
	}
	bool getDataTypeExists(Netcode::MessageType type_) {
		for (auto& type : m_dataTypes)	{
			if (type == type_) {
				return true;
			}
		}
		return false;
	}

	Netcode::NetworkComponentID m_id;
	Netcode::EntityType m_entityType;

	// Could eventually be changed to a list of types if there are multiple data types per entity one wants to send over the network
	std::vector<Netcode::MessageType> m_dataTypes;
	Netcode::MessageType m_dataType;
};
